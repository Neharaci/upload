from collections import deque
from queue import PriorityQueue

#Simple A* Search 
def heuristic(node, goal, coords):
    x1, y1 = coords[node]
    x2, y2 = coords[goal]
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

def astar(graph, start, end, coords):
    frontier = PriorityQueue()
    frontier.put((0, start))
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        _, current = frontier.get()

        if current == end:
            path = []
            while current:
                path.append(current)
                current = came_from[current]
            return path[::-1]

        for neighbor, cost in graph.get(current, []):
            new_cost = cost_so_far[current] + cost
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + heuristic(neighbor, end, coords)
                frontier.put((priority, neighbor))
                came_from[neighbor] = current
    return None

#Simple BFS
def bfs(graph, start, end):
    queue = deque([[start]])
    visited = set([start])

    while queue:
        path = queue.popleft()
        node = path[-1]
        if node == end:
            return path
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(path + [neighbor])
    return None

#  Simple UCS 
def ucs(graph, start, end):
    frontier = PriorityQueue()
    frontier.put((0, start))
    came_from = {start: None}
    cost_so_far = {start: 0}

    while not frontier.empty():
        cost, current = frontier.get()
        if current == end:
            path = []
            while current:
                path.append(current)
                current = came_from[current]
            return path[::-1]
        for neighbor, edge_cost in graph.get(current, []):
            total = cost_so_far[current] + edge_cost
            if neighbor not in cost_so_far or total < cost_so_far[neighbor]:
                cost_so_far[neighbor] = total
                frontier.put((total, neighbor))
                came_from[neighbor] = current
    return None

if __name__ == "__main__":
    weighted_graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 10), ('D', 2), ('E', 5)],
        'C': [('A', 4), ('F', 3)],
        'D': [('B', 2)],
        'E': [('B', 5), ('F', 1)],
        'F': [('C', 3), ('E', 1)]
    }
    neighbors_graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }
    coords = {
        'A': (0, 5),
        'B': (1, 3),
        'C': (4, 2),
        'D': (0, 2),
        'E': (3, 1),
        'F': (5, 0)
    }

    start = 'A'
    end = 'F'

    print("A* path:", astar(weighted_graph, start, end, coords))
    print("BFS path:", bfs(neighbors_graph, start, end))
    print("UCS path:", ucs(weighted_graph, start, end))
